/**
 * 文件名	：CrashHandler.java
 * 创建日期	：2012-11-02
 * Copyright (c) 2003-2012 北京联龙博通

 * All rights reserved.
 */
package com.aizou.core.exception;

import android.os.Build;


import com.aizou.core.base.BaseApplication;
import com.aizou.core.log.LogGloble;
import com.aizou.core.log.LogManager;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.Thread.UncaughtExceptionHandler;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * 描述:CrashHandler
 * <p />
 * 
 * 继承自 UncaughtExceptionHandler
 * <p />
 * 
 * UncaughtException处理类,当程序发生Uncaught异常的时候,由该类来接管程序,并记录发送错误报告.
 * </p>
 * 
 * 如果程序出现了未捕获异常默认情况下则会出现强行关闭对话框 </p>
 * 
 * 实现该接口并注册为程序中的默认未捕获异常处理 这样当未捕获异常发生时，就可以做些异常处理操作</p>
 * 
 * 例如：收集异常信息，发送错误报告 等。
 * 
 * @version 1.00
 * 
 */
public class CrashHandler implements UncaughtExceptionHandler {
	public static final String TAG = "CrashHandler"; // log tag
	private static CrashHandler INSTANCE = null;
	private Thread.UncaughtExceptionHandler mDefaultHandler;// UncaughtExceptionHandler
	private final SimpleDateFormat SDF = new SimpleDateFormat("yyyyMMdd.HHmmss");

	private CrashHandler() {
	}

	/**
	 * 获取实例
	 * 
	 * @return
	 */
	public static CrashHandler getInstance() {
		if (INSTANCE == null) {
			INSTANCE = new CrashHandler();
		}
		return INSTANCE;
	}

	/**
	 * 初始化
	 */
	public void init() {
		mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();
		Thread.setDefaultUncaughtExceptionHandler(this);
	}

	/**
	 * 当UncaughtException发生时会转入该函数来处理
	 * 
	 * @param thread
	 * @param ex
	 */
	@Override
	public void uncaughtException(Thread thread, Throwable ex) {
		if (!handleException(ex) && mDefaultHandler != null) {
			// 如果用户没有单独处理,则让系统默认的异常处理器来处理
			// LogGloble.d(TAG, "系统默认的异常处理器来处理");
			mDefaultHandler.uncaughtException(thread, ex);
		} else {
			//终止当前出现uncaughtException的activity
			android.os.Process.killProcess(android.os.Process.myPid());
			System.exit(1);
		}

	}

	/**
	 * 自定义错误处理,收集错误信息 发送错误报告等操作均在此完成. 开发者可以根据自己的情况来自定义异常处理逻辑
	 * 
	 * @param ex
	 * 
	 * @return true:如果处理了该异常信息; 否则返回false
	 */
	private boolean handleException(Throwable ex) {
		LogGloble.e(TAG, "UncaughtExceptionHandler", ex);
		if (ex == null) {
			return true;
		} else {
			// 写入错误信息到本地文件
			processException(ex);
		}
		return true;
	}

	/**
	 * 处理Exception(记录日志)
	 * 
	 * @param th
	 */
	public void processException(Throwable th) {
		try {
			if (th == null) {
				return;
			}
			String timestamp = SDF.format(new Date());

			Writer result = new StringWriter();
			PrintWriter printWriter = new PrintWriter(result);

			th.printStackTrace(printWriter);
			String stacktrace = result.toString();
			printWriter.close();

			String name = BaseApplication.APP_PACKAGE + "." + BaseApplication.APP_VERSION_NAME + "." + timestamp
					+ ".stacktrace";
			LogGloble.d("info", "-----dir = "+ LogManager.LOG_STORAGE+"  name = "+name);
			File filename = new File(LogManager.LOG_STORAGE, name);
			if(!filename.exists()){
				filename.createNewFile();
			}
			writeToFile(stacktrace, filename);
		} catch (Exception e) {
			LogGloble.w(TAG, "processException Exception", e);
		}
	}

	/**
	 * 写日志
	 * 
	 * @param stacktrace
	 * @param filename
	 */
	private void writeToFile(String stacktrace, File filename) {
		try {
			if (filename != null) {
				BufferedWriter bos = new BufferedWriter(new FileWriter(filename));

				bos.write("Application information:\n\n");
				bos.write("This file was generated by the " + BaseApplication.APP_PACKAGE + "."
						+ BaseApplication.APP_VERSION_NAME + "\n");
				bos.write("\nDevice information:\n\n");
				bos.write("BOARD       : " + Build.BOARD + "\n");
				bos.write("BRAND       : " + Build.BRAND + "\n");
				bos.write("CPU_ABI     : " + BaseApplication.BUILD_PROPS.getProperty("ro.product.cpu.abi") + "\n");
				bos.write("CPU_ABI2    : " + BaseApplication.BUILD_PROPS.getProperty("ro.product.cpu.abi2") + "\n");
				bos.write("DEVICE      : " + Build.DEVICE + "\n");
				bos.write("DISPLAY     : " + Build.DISPLAY + "\n");
				bos.write("FINGERPRINT : " + Build.FINGERPRINT + "\n");
				bos.write("ID          : " + Build.ID + "\n");
				bos.write("MANUFACTURER: " + BaseApplication.BUILD_PROPS.getProperty("ro.product.manufacturer") + "\n");
				bos.write("MODEL       : " + Build.MODEL + "\n");
				bos.write("PRODUCT     : " + Build.PRODUCT + "\n");
				bos.write("\nError information:\n\n");
				bos.write(stacktrace);
				bos.flush();
				bos.close();
				LogGloble.d(TAG, "Stacktrace is written: " + filename);
			} else {
				LogGloble.d(TAG, "Stacktrace  written fail.");
			}

		} catch (final Exception e) {
			LogGloble.e(TAG, "writeToFile fail", e);
		}
	}

}